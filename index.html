<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>-NINE Büí£MB-</title>
<style>
  :root{ --cell-size: calc(min(22vw,90px)); }
  body{ margin:0; font-family:Arial,Helvetica,sans-serif; background:#222; color:#fff; text-align:center; -webkit-tap-highlight-color: transparent; }
  h1{ margin:12px 0; font-size:20px; }
  #grid{ width:90vw; max-width:320px; margin:8px auto; display:grid; grid-template-columns:repeat(3,1fr); gap:6px; }
  .cell{ background:#ccc; border-radius:8px; aspect-ratio:1/1; transition:background .12s; }
  #status{ margin:8px 0; font-size:14px; }
  #controller{ display:flex; justify-content:center; align-items:flex-start; gap:20px; margin:10px auto 24px; max-width:420px; }
  /* D-pad: center is blank. layout rows:
     [  . , UP  ,  . ]
     [ LEFT,  . , RIGHT]
     [  . , DOWN,  . ]
  */
  #dpad{ display:grid; grid-template-columns:60px 60px 60px; grid-template-rows:60px 60px 60px; gap:6px; }
  .btn{ width:60px; height:60px; border-radius:10px; border:none; background:#2196F3; color:#fff; font-size:18px; cursor:pointer; }
  .btn:active{ background:#1976D2; }
  .blank{ background:transparent; pointer-events:none; }
  #side-controls{ display:flex; flex-direction:column; align-items:center; gap:8px; }
  #bombBtn{ width:74px; height:74px; background:#FF4C4C; border-radius:12px; border:none; color:#fff; font-weight:600; cursor:pointer; }
  #resetBtn{ width:74px; height:36px; background:#777; border:none; border-radius:8px; color:#fff; cursor:pointer; }
  @media (max-width:520px){
    :root{ --cell-size: calc(min(44vw,72px)); }
    #dpad{ grid-template-columns:50px 50px 50px; grid-template-rows:50px 50px 50px; gap:6px; }
    .btn{ width:50px; height:50px; font-size:16px; }
    #bombBtn{ width:64px; height:64px; }
    #resetBtn{ width:64px; }
  }
</style>
</head>
<body>
  <h1>-NINE Büí£MB-</h1>

  <div id="grid"></div>
  <div id="status">WIN: 0&nbsp;&nbsp;LOSE: 0&nbsp;&nbsp;STREAK: 0</div>

  <div id="controller">
    <div id="dpad">
      <div class="blank"></div>
      <button class="btn" data-dir="up">‚Üë</button>
      <div class="blank"></div>

      <button class="btn" data-dir="left">‚Üê</button>
      <div class="blank"></div>
      <button class="btn" data-dir="right">‚Üí</button>

      <div class="blank"></div>
      <button class="btn" data-dir="down">‚Üì</button>
      <div class="blank"></div>
    </div>

    <div id="side-controls">
      <button id="bombBtn">BOMB</button>
      <button id="resetBtn">RESET</button>
    </div>
  </div>

<script>
/* --- Ë®≠ÂÆö --- */
const GRID = 3;
const EXPLODE_DELAY = 700; // ms
const EXPLODE_SHOW = 400; // ms that blast stays visible
const ENEMY_MOVE_INTERVAL = 500; // ms
const ENEMY_MOVE_AFTER_BOMB_STEPS = 2; // move steps to avoid self-destruct

/* --- Áä∂ÊÖã --- */
let player = { x: 2, y: 2 };
let enemy  = { x: 0, y: 0 };
let bombs  = []; // {x,y}
let gameStarted = false;
let gameOver = false;
let enemyPaused = false;
let enemyBombCooldown = 0;
let wins = 0, losses = 0, streak = 0;
let enemyTimer = null;

/* --- DOM --- */
const gridEl = document.getElementById('grid');
const statusEl = document.getElementById('status');
const bombBtn = document.getElementById('bombBtn');
const resetBtn = document.getElementById('resetBtn');
const dpadBtns = Array.from(document.querySelectorAll('#dpad .btn'));

/* --- ÂàùÊúüÂåñ --- */
function createGrid(){
  gridEl.innerHTML = '';
  for(let i=0;i<GRID*GRID;i++){
    const c = document.createElement('div');
    c.className = 'cell';
    gridEl.appendChild(c);
  }
  render();
}
function cellIndex(x,y){ return y*GRID + x; }

/* --- ÊèèÁîª --- */
function render(){
  const cells = gridEl.querySelectorAll('.cell');
  cells.forEach(c => c.style.background = '#ccc');

  // bombs (block movement)
  bombs.forEach(b => {
    const idx = cellIndex(b.x,b.y);
    cells[idx].style.background = '#FF4C4C'; // bomb red
  });

  // player / enemy
  if(!(gameOver && !playerVisible())) { // always show enemy except when we intentionally hide
    const eIdx = cellIndex(enemy.x, enemy.y);
    cells[eIdx].style.background = '#E91E63';
  }
  if(playerVisible()){
    const pIdx = cellIndex(player.x, player.y);
    cells[pIdx].style.background = '#4CAF50';
  }
}
function playerVisible(){ return true; }

/* --- „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£ --- */
function isBombAt(x,y){ return bombs.some(b => b.x===x && b.y===y); }
function canMoveTo(x,y){
  if(x<0||x>=GRID||y<0||y>=GRID) return false;
  if(isBombAt(x,y)) return false;
  return true;
}

/* --- „Éó„É¨„Ç§„É§„ÉºÊìç‰Ωú --- */
function movePlayer(dir){
  if(!gameStarted || gameOver) return;
  let nx = player.x, ny = player.y;
  if(dir === 'up') ny--;
  if(dir === 'down') ny++;
  if(dir === 'left') nx--;
  if(dir === 'right') nx++;
  if(canMoveTo(nx,ny) && !(nx===enemy.x && ny===enemy.y)){
    player.x = nx; player.y = ny;
    render();
  }
}

/* --- ÁàÜÂºæË®≠ÁΩÆ --- */
function placeBombAt(x,y, byEnemy=false){
  if(!gameStarted || gameOver) return;
  if(isBombAt(x,y)) return;
  bombs.push({x,y});
  render();

  // when bomb placed, enemy should move away and wait until explosion
  if(!byEnemy){
    // if player placed, enemy will try to avoid: move steps and pause
    enemyPaused = true;
    moveEnemySteps(ENEMY_MOVE_AFTER_BOMB_STEPS, () => {
      // remain paused until explosion completes (handled in explode)
    });
  } else {
    // enemy placed; move away then pause until explosion
    enemyPaused = true;
    moveEnemySteps(ENEMY_MOVE_AFTER_BOMB_STEPS, () => {
      // same as above
    });
  }

  // schedule explode
  setTimeout(() => explodeAt(x,y), EXPLODE_DELAY);
}

/* --- ÁàÜÁô∫Âá¶ÁêÜ --- */
function explodeAt(x,y){
  // mark blast cells (center + cross)
  const blast = [
    {x,y},
    {x:x-1,y},
    {x:x+1,y},
    {x,y:y-1},
    {x,y:y+1}
  ].filter(p => p.x>=0 && p.x<GRID && p.y>=0 && p.y<GRID);

  // draw blast (bright yellow)
  const cells = gridEl.querySelectorAll('.cell');
  blast.forEach(p => {
    cells[cellIndex(p.x,p.y)].style.background = '#FFFF33';
  });

  // check hits
  const hitPlayer = blast.some(p => p.x===player.x && p.y===player.y);
  const hitEnemy  = blast.some(p => p.x===enemy.x && p.y===enemy.y);

  if(hitPlayer && !hitEnemy){
    gameOver = true;
    losses++;
    streak = 0;
    updateStatus('GAME OVER');
  } else if(hitEnemy && !hitPlayer){
    gameOver = true;
    wins++;
    streak++;
    updateStatus('NICE GAME!');
  } else if(hitEnemy && hitPlayer){
    gameOver = true;
    // tie: count as no streak
    streak = 0;
    updateStatus('DRAW');
  }

  // remove bomb from list after explode
  bombs = bombs.filter(b => !(b.x===x && b.y===y));

  // keep blast visible briefly then clear
  setTimeout(() => {
    // restore cells and render normal
    render();
    // unpause enemy after explosion done
    enemyPaused = false;
    if(gameOver) { resetPositions(); stopEnemyTimer(); }
  }, EXPLODE_SHOW);
}

/* --- ÊïµÁßªÂãïÔºà„É©„É≥„ÉÄ„É†Ôºâ --- */
function moveEnemyRandom(){
  if(!gameStarted || gameOver || enemyPaused) return;
  const dirs = [{x:0,y:1},{x:0,y:-1},{x:1,y:0},{x:-1,y:0}].sort(()=>Math.random()-0.5);
  for(const d of dirs){
    const nx = enemy.x + d.x, ny = enemy.y + d.y;
    if(canMoveTo(nx,ny) && !(nx===player.x && ny===player.y)){
      enemy.x = nx; enemy.y = ny;
      break;
    }
  }
  render();

  // enemy occasionally places a bomb, but avoid placing on top of bomb
  if(enemyBombCooldown <= 0 && Math.random() < 0.25){
    placeBombAt(enemy.x, enemy.y, true);
    enemyBombCooldown = 3;
  } else {
    enemyBombCooldown = Math.max(0, enemyBombCooldown-1);
  }
}

/* --- Êïµ„ÅåÁàÜÂºæ„ÇíÁΩÆ„ÅÑ„Åü/ÁΩÆ„Åã„Çå„ÅüÂæå„Å´ÊåáÂÆöÂõûÊï∞„Å†„ÅëÂÆâÂÖ®„Å´ÁßªÂãï„Åô„Çã --- */
function moveEnemySteps(steps, doneCallback){
  if(steps <= 0){
    if(doneCallback) doneCallback();
    return;
  }
  // choose a safe move (prefer non-bomb tiles, not into player)
  const cand = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}].sort(()=>Math.random()-0.5);
  for(const d of cand){
    const nx = enemy.x + d.x, ny = enemy.y + d.y;
    if(canMoveTo(nx,ny) && !(nx===player.x && ny===player.y)){
      enemy.x = nx; enemy.y = ny;
      render();
      // schedule next step slightly delayed for visual
      setTimeout(() => moveEnemySteps(steps-1, doneCallback), 200);
      return;
    }
  }
  // if no move possible just call next step (avoid infinite)
  setTimeout(() => moveEnemySteps(steps-1, doneCallback), 200);
}

/* --- „Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞ --- */
function updateStatus(msg){
  const base = `WIN: ${wins}  LOSE: ${losses}  STREAK: ${streak}`;
  statusEl.textContent = msg ? (msg + '   ' + base) : base;
}

/* --- „Ç≤„Éº„É†ÈñãÂßã / „É™„Çª„ÉÉ„Éà --- */
function startGame(){
  if(enemyTimer) clearInterval(enemyTimer);
  player = {x:2, y:2};
  enemy  = {x:0, y:0};
  bombs = [];
  gameStarted = true;
  gameOver = false;
  enemyPaused = false;
  enemyBombCooldown = 0;
  updateStatus();
  render();
  enemyTimer = setInterval(moveEnemyRandom, ENEMY_MOVE_INTERVAL);
}

function resetAll(){
  wins = 0; losses = 0; streak = 0;
  startGame();
}

function stopEnemyTimer(){
  if(enemyTimer){ clearInterval(enemyTimer); enemyTimer = null; }
}

function resetPositions(){
  // keep wins/losses but return to initial positions and wait for user to press BOMB to start again
  stopEnemyTimer();
  gameStarted = false;
  setTimeout(() => {
    player = {x:2,y:2};
    enemy = {x:0,y:0};
    bombs = [];
    enemyPaused = false;
    render();
    updateStatus();
  }, 250);
}

/* --- UI „Ç§„Éô„É≥„Éà --- */
dpadBtns.forEach(btn=>{
  btn.addEventListener('click', ()=> {
    const dir = btn.dataset.dir;
    if(dir) movePlayer(dir);
  });
});

bombBtn.addEventListener('click', ()=>{
  if(!gameStarted){
    startGame();
    // if user immediately wants to place bomb first click will just start; second click places
    return;
  }
  // place bomb at player's position
  placeBombAt(player.x, player.y, false);
});

resetBtn.addEventListener('click', resetAll);

/* „Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú */
document.addEventListener('keydown', e=>{
  if(e.key === 'Enter'){ if(!gameStarted) startGame(); return; }
  if(e.key === ' ') { // space bomb
    e.preventDefault();
    if(!gameStarted) startGame();
    else placeBombAt(player.x, player.y, false);
    return;
  }
  if(!gameStarted || gameOver) return;
  if(e.key === 'ArrowUp') movePlayer('up');
  if(e.key === 'ArrowDown') movePlayer('down');
  if(e.key === 'ArrowLeft') movePlayer('left');
  if(e.key === 'ArrowRight') movePlayer('right');
});

/* „Çø„ÉÉ„ÉÅ„ÉÄ„Éñ„É´„Çø„ÉÉ„Éó„Ç∫„Éº„É†ÁÑ°ÂäπÂåñÔºàËªΩ„ÅÑ„Ç¨„Éº„ÉâÔºâ */
let lastTouchEnd = 0;
document.addEventListener('touchend', function(e){
  const now = Date.now();
  if(now - lastTouchEnd <= 300) e.preventDefault();
  lastTouchEnd = now;
}, false);

/* ÂàùÊúüÊèèÁîª */
createGrid();
updateStatus();
</script>
</body>
</html>
